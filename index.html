<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Battle Tetris</title>

  <!-- Phaser 3 -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>

  <!-- Firebase (compat SDKs for easiest syntax) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <style>
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #2a2a5a 0%, #111133 35%, #03030a 70%, #000 100%);
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
    }
    #top-bar {
      display: flex;
      justify-content: space-between;
      padding: 8px 16px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      font-size: 14px;
      border-bottom: 2px solid #444;
      box-shadow: 0 2px 8px #000;
    }
    #hud {
      font-size: 14px;
    }
    #hud strong {
      color: #ffcc00;
    }
    #content {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 30px;
      padding: 20px;
      box-sizing: border-box;
    }
    #game-container {
      border: 3px solid #888;
      box-shadow: 0 0 20px #000, 0 0 40px rgba(255, 152, 0, 0.2);
      background: #000;
    }
    #leaderboard {
      width: 280px;
      background: rgba(5, 5, 15, 0.95);
      color: #fff;
      border: 2px solid #555;
      padding: 10px;
      font-size: 14px;
      box-shadow: 0 0 20px #000;
      border-radius: 8px;
    }
    #leaderboard h3 {
      margin: 0 0 6px 0;
      font-size: 18px;
      text-align: center;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: #ffcc00;
      text-shadow: 0 0 6px #ff9800;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(40,40,80,0.95), rgba(0,0,0,0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      z-index: 10;
    }
    .hidden {
      display: none !important;
    }
    .overlay-box {
      background: linear-gradient(145deg, #060614, #111122);
      padding: 20px 24px;
      border-radius: 12px;
      max-width: 480px;
      text-align: center;
      box-shadow: 0 0 25px #000, 0 0 40px rgba(0, 255, 255, 0.25);
      border: 2px solid #444;
    }
    .overlay-box h1 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 32px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: #ffcc00;
      text-shadow:
        0 0 6px #ff9800,
        0 0 12px #ff9800,
        0 0 16px #ff5722;
    }
    /* Pulsating neon title */
    #title-text {
      animation: titlePulse 1.4s infinite alternate;
    }
    @keyframes titlePulse {
      from {
        transform: scale(1);
        text-shadow:
          0 0 6px #ff9800,
          0 0 12px #ff9800,
          0 0 16px #ff5722;
      }
      to {
        transform: scale(1.08);
        text-shadow:
          0 0 10px #ffeb3b,
          0 0 20px #ffc107,
          0 0 30px #ff5722;
      }
    }

    .overlay-box h2 {
      margin-top: 8px;
      font-size: 20px;
      color: #90caf9;
    }
    .overlay-box p {
      font-size: 14px;
    }
    .overlay-box input {
      width: 80%;
      padding: 6px;
      margin: 4px 0 10px 0;
      border-radius: 4px;
      border: 1px solid #555;
      font-size: 14px;
      background: #050514;
      color: #fff;
    }
    .overlay-box button {
      margin: 6px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .answer-btn {
      background: #4caf50;
      color: #fff;
    }
    .store-btn {
      background: #2196f3;
      color: #fff;
    }
    .close-btn {
      background: #777;
      color: #fff;
    }
    .primary-btn {
      background: linear-gradient(90deg, #ff9800, #ffc107);
      color: #000;
      font-weight: bold;
      box-shadow: 0 0 10px #ff9800;
    }
  </style>
</head>
<body>

<div id="top-bar">
  <div id="hud">
    <span id="hud-name"></span> |
    Score: <span id="hud-score">0</span> |
    Lines: <span id="hud-lines">0</span> |
    Coins: <span id="hud-coins">0</span> |
    Shield: <span id="hud-shield">OFF</span>
    &nbsp;&nbsp;&nbsp;
    <strong>[E] Store</strong>
  </div>
  <div>
    Room: <span id="hud-room"></span>
  </div>
</div>

<div id="content">
  <div id="game-container"></div>

  <div id="leaderboard">
    <h3>Leaderboard</h3>
    <div id="leaderboard-body">Waiting for players...</div>
  </div>
</div>

<!-- Start / Title overlay -->
<div id="start-overlay" class="overlay">
  <div class="overlay-box">
    <h1 id="title-text">Battle Tetris</h1>
    <p>Answer questions, clear lines, earn coins, and attack your classmates.</p>
    <h2>Join Game</h2>
    <input id="start-name" placeholder="Your name" />
    <br>
    <input id="start-room" placeholder="Room code (e.g., Hour1)" value="Room1" />
    <br>
    <button id="start-button" class="primary-btn">Start</button>
    <p style="margin-top:10px;font-size:12px;">
      Everyone with the same room code shares a leaderboard and can attack each other.
    </p>
  </div>
</div>

<!-- Question overlay -->
<div id="question-overlay" class="overlay hidden">
  <div class="overlay-box">
    <h2>Answer the question!</h2>
    <div id="question-text" style="margin-bottom: 10px;"></div>
    <div id="answers"></div>
  </div>
</div>

<!-- Store overlay -->
<div id="store-overlay" class="overlay hidden">
  <div class="overlay-box">
    <h2>Store</h2>
    <p>Use coins to attack or defend.</p>
    <p><strong>Attacks (hit random opponent in your room):</strong></p>
    <button class="store-btn" id="buy-garbage2">Garbage +2 (3 coins)</button>
    <button class="store-btn" id="buy-garbage4">Garbage +4 (5 coins)</button>
    <p><strong>Defense / Utility:</strong></p>
    <button class="store-btn" id="buy-shield">Shield (next attack blocked) (4 coins)</button>
    <button class="store-btn" id="buy-clear">Clear 2 bottom lines (5 coins)</button>
    <br><br>
    <button class="close-btn" id="store-close">Close Store (E)</button>
  </div>
</div>

<script>
  // ==========================
  // 1. FIREBASE CONFIG (your project)
  // ==========================
  const firebaseConfig = {
    apiKey: "AIzaSyCclM56_skM11x7_qXW08eB2gx-n7T9tJY",
    authDomain: "battle-tetris-2c247.firebaseapp.com",
    projectId: "battle-tetris-2c247",
    storageBucket: "battle-tetris-2c247.firebasestorage.app",
    messagingSenderId: "275712305914",
    appId: "1:275712305914:web:b5115418725f5703163743",
    measurementId: "G-ZQBZYEY1EK"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // ==========================
  // 2. QUESTION BANK (swap with textbook questions)
  // ==========================
  const QUESTIONS = [
    {
      text: "Sample Question 1: 2 + 2 = ?",
      options: ["1","2","3","4"],
      correctIndex: 3
    },
    {
      text: "Sample Question 2: Capital of France?",
      options: ["Paris","London","Rome","Berlin"],
      correctIndex: 0
    },
    {
      text: "Sample Question 3: The color of the sky is usually?",
      options: ["Red","Blue","Green","Yellow"],
      correctIndex: 1
    }
    // Add up to 20 questions here
  ];

  // ==========================
  // 3. GLOBAL VARS
  // ==========================
  const WIDTH = 10;
  const HEIGHT = 22;
  const GRID = 32;  // bigger blocks / larger playfield

  let board;
  let game;
  let graphics;

  let score = 0;
  let linesCleared = 0;
  let coins = 0;
  let shieldActive = false;

  let questionIndex = 0;
  let questionActive = false;
  let storeOpen = false;

  let dropTimer = 0;
  let dropInterval = 500;
  let cursors;
  let keySpace;
  let keyE;

  let playerName = "Player";
  let roomId = "Room1";
  let playerDocId = null;

  let currentPlayers = [];

  // sound
  let sfx = {};
  let bgm;

  const hudName = document.getElementById('hud-name');
  const hudScore = document.getElementById('hud-score');
  const hudLines = document.getElementById('hud-lines');
  const hudCoins = document.getElementById('hud-coins');
  const hudShield = document.getElementById('hud-shield');
  const hudRoom = document.getElementById('hud-room');
  const leaderboardBody = document.getElementById('leaderboard-body');

  const startOverlay = document.getElementById('start-overlay');
  const startNameInput = document.getElementById('start-name');
  const startRoomInput = document.getElementById('start-room');
  const startButton = document.getElementById('start-button');

  const storeOverlay = document.getElementById('store-overlay');
  const btnGarbage2 = document.getElementById('buy-garbage2');
  const btnGarbage4 = document.getElementById('buy-garbage4');
  const btnShield = document.getElementById('buy-shield');
  const btnClear = document.getElementById('buy-clear');
  const btnStoreClose = document.getElementById('store-close');

  const questionOverlay = document.getElementById('question-overlay');
  const questionText = document.getElementById('question-text');
  const answersDiv = document.getElementById('answers');

  function playSfx(name) {
    if (sfx[name]) sfx[name].play();
  }

  // Start screen handler
  startButton.onclick = () => {
    playerName = (startNameInput.value || "Anonymous").trim();
    roomId = (startRoomInput.value || "Room1").trim();
    playerDocId = playerName + "_" + Math.floor(Math.random() * 1000000);

    hudName.textContent = playerName;
    hudRoom.textContent = roomId;

    startOverlay.classList.add('hidden');
    startGame();
  };

  // ==========================
  // 4. TETRIS LOGIC
  // ==========================
  const SHAPES = {
    NONE: 0,
    I: 1,
    L: 2,
    J: 3,
    T: 4,
    O: 5,
    S: 6,
    Z: 7
  };

  const SHAPE_COORDS = {
    [SHAPES.NONE]: [[0,0],[0,0],[0,0],[0,0]],
    [SHAPES.I]:    [[0,-1],[0,0],[0,1],[0,2]],
    [SHAPES.L]:    [[0,-1],[0,0],[0,1],[1,1]],
    [SHAPES.J]:    [[0,-1],[0,0],[0,1],[-1,1]],
    [SHAPES.T]:    [[0,-1],[0,0],[0,1],[1,0]],
    [SHAPES.O]:    [[0,0],[0,-1],[1,0],[1,-1]],
    [SHAPES.S]:    [[0,0],[0,-1],[-1,0],[1,-1]],
    [SHAPES.Z]:    [[0,0],[0,-1],[1,0],[-1,-1]]
  };

  function rotatedOffsets(shape, dir) {
    const coords = SHAPE_COORDS[shape];
    if (dir === 0 || shape === SHAPES.O) return coords;

    if (dir === 1) {
      return coords.map(([x,y]) => [-y, x]);
    }
    if (dir === 2) {
      if ([SHAPES.I, SHAPES.Z, SHAPES.S].includes(shape)) return coords;
      return coords.map(([x,y]) => [-x, -y]);
    }
    if (dir === 3) {
      if ([SHAPES.I, SHAPES.Z, SHAPES.S].includes(shape)) {
        return coords.map(([x,y]) => [-y, x]);
      }
      return coords.map(([x,y]) => [y, -x]);
    }
  }

  class Board {
    constructor() {
      this.width = WIDTH;
      this.height = HEIGHT;
      this.backBoard = new Array(WIDTH * HEIGHT).fill(0);
      this.currentShape = SHAPES.NONE;
      this.currentX = -1;
      this.currentY = -1;
      this.currentDir = 0;
      this.nextShape = this.randomShape();
    }
    randomShape() {
      return 1 + Math.floor(Math.random() * 7);
    }
    value(x,y) {
      return this.backBoard[x + y * this.width];
    }
    coords(shape, dir, x, y) {
      return rotatedOffsets(shape, dir).map(([dx,dy]) => [x + dx, y + dy]);
    }
    tryMove(shape, dir, x, y) {
      for (const [xx, yy] of this.coords(shape, dir, x, y)) {
        if (xx < 0 || xx >= this.width || yy < 0 || yy >= this.height) return false;
        if (this.backBoard[xx + yy * this.width] > 0) return false;
      }
      return true;
    }
    spawn() {
      const shape = this.nextShape;
      this.currentShape = shape;
      this.currentDir = 0;
      this.currentX = 5;
      this.currentY = 1;
      this.nextShape = this.randomShape();

      if (!this.tryMove(this.currentShape, this.currentDir, this.currentX, this.currentY)) {
        this.backBoard.fill(0);
        score = 0;
        linesCleared = 0;
        coins = 0;
        shieldActive = false;
        recalcScore();
      }
    }
    stepDown() {
      if (this.tryMove(this.currentShape, this.currentDir, this.currentX, this.currentY + 1)) {
        this.currentY++;
        return 0;
      }
      this.merge();
      const lines = this.removeFullLines();
      this.spawn();
      return lines;
    }
    dropDown() {
      while (this.tryMove(this.currentShape, this.currentDir, this.currentX, this.currentY + 1)) {
        this.currentY++;
      }
      this.merge();
      const lines = this.removeFullLines();
      this.spawn();
      return lines;
    }
    merge() {
      for (const [x,y] of this.coords(this.currentShape, this.currentDir, this.currentX, this.currentY)) {
        this.backBoard[x + y * this.width] = this.currentShape;
      }
      this.currentShape = SHAPES.NONE;
    }
    removeFullLines() {
      let lines = 0;
      const newBoard = new Array(this.width * this.height).fill(0);
      let newY = this.height - 1;
      for (let y = this.height - 1; y >= 0; y--) {
        let count = 0;
        for (let x = 0; x < this.width; x++) {
          if (this.backBoard[x + y * this.width] > 0) count++;
        }
        if (count < this.width) {
          for (let x = 0; x < this.width; x++) {
            newBoard[x + newY * this.width] = this.backBoard[x + y * this.width];
          }
          newY--;
        } else {
          lines++;
        }
      }
      this.backBoard = newBoard;
      return lines;
    }
    clearTopFilledRow() {
      for (let y = 0; y < this.height; y++) {
        let any = false;
        for (let x = 0; x < this.width; x++) {
          if (this.backBoard[x + y * this.width] > 0) {
            any = true;
            break;
          }
        }
        if (any) {
          for (let x = 0; x < this.width; x++) {
            this.backBoard[x + y * this.width] = 0;
          }
          return;
        }
      }
    }
    addGarbageLines(count) {
      for (let i = 0; i < count; i++) {
        for (let y = 0; y < this.height - 1; y++) {
          for (let x = 0; x < this.width; x++) {
            this.backBoard[x + y * this.width] = this.backBoard[x + (y + 1) * this.width];
          }
        }
        const hole = Math.floor(Math.random() * this.width);
        for (let x = 0; x < this.width; x++) {
          this.backBoard[x + (this.height - 1) * this.width] = (x === hole) ? 0 : 8;
        }
      }
    }
    clearBottomLines(count) {
      for (let c = 0; c < count; c++) {
        for (let x = 0; x < this.width; x++) {
          this.backBoard[x + (this.height - 1) * this.width] = 0;
        }
      }
    }
  }

  // simple wall-kick rotate: try rotate in place, then x-1, then x+1
  function attemptRotate(delta) {
    if (!board || board.currentShape === SHAPES.NONE) return;
    const newDir = (board.currentDir + delta + 4) % 4;
    const x = board.currentX;
    const y = board.currentY;

    if (board.tryMove(board.currentShape, newDir, x, y)) {
      board.currentDir = newDir;
      playSfx('rotate');
      return;
    }
    if (board.tryMove(board.currentShape, newDir, x - 1, y)) {
      board.currentX = x - 1;
      board.currentDir = newDir;
      playSfx('rotate');
      return;
    }
    if (board.tryMove(board.currentShape, newDir, x + 1, y)) {
      board.currentX = x + 1;
      board.currentDir = newDir;
      playSfx('rotate');
      return;
    }
  }

  // ==========================
  // 5. START GAME (PHASER + LISTENERS)
  // ==========================
  function startGame() {
    const config = {
      type: Phaser.AUTO,
      width: WIDTH * GRID,
      height: HEIGHT * GRID,
      parent: 'game-container',
      backgroundColor: '#050814',
      scene: { preload, create, update }
    };
    game = new Phaser.Game(config);

    window.addEventListener('beforeunload', () => {
      if (playerDocId) {
        db.collection('tetrisPlayers').doc(playerDocId).delete().catch(() => {});
      }
    });
  }

  function preload() {
    // Audio assets (from /sounds)
    this.load.audio('move',   'sounds/move.wav');
    this.load.audio('rotate', 'sounds/rotate.wav');
    this.load.audio('drop',   'sounds/drop.wav');
    this.load.audio('line',   'sounds/line.wav');
    this.load.audio('attack', 'sounds/attack.wav');
    this.load.audio('hit',    'sounds/hit.wav');
    this.load.audio('bgm',    'sounds/bgm.mp3');
  }

  function create() {
    board = new Board();
    board.spawn();
    graphics = this.add.graphics();

    // setup sounds
    sfx.move   = this.sound.add('move',   { volume: 0.25 });
    sfx.rotate = this.sound.add('rotate', { volume: 0.25 });
    sfx.drop   = this.sound.add('drop',   { volume: 0.3 });
    sfx.line   = this.sound.add('line',   { volume: 0.3 });
    sfx.attack = this.sound.add('attack', { volume: 0.4 });
    sfx.hit    = this.sound.add('hit',    { volume: 0.4 });

    bgm = this.sound.add('bgm', { loop: true, volume: 0.18 });
    if (bgm) bgm.play();

    cursors = this.input.keyboard.createCursorKeys();
    keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    keyE = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

    keySpace.on('down', () => {
      if (questionActive || storeOpen) return;
      const lines = board.dropDown();
      playSfx('drop');
      if (lines > 0) onLinesCleared(lines);
    });

    this.input.keyboard.on('keydown', (event) => {
      if (questionActive || storeOpen) return;
      switch (event.code) {
        case 'ArrowLeft':
          if (board.tryMove(board.currentShape, board.currentDir, board.currentX - 1, board.currentY)) {
            board.currentX--;
            playSfx('move');
          }
          break;
        case 'ArrowRight':
          if (board.tryMove(board.currentShape, board.currentDir, board.currentX + 1, board.currentY)) {
            board.currentX++;
            playSfx('move');
          }
          break;
        case 'ArrowUp':
          attemptRotate(1);
          break;
      }
    });

    keyE.on('down', () => {
      if (questionActive) return;
      if (storeOpen) closeStore();
      else openStore();
    });

    this.time.addEvent({
      delay: 60000,
      loop: true,
      callback: () => {
        if (!storeOpen) askQuestion();
      }
    });

    recalcScore();
    setupFirestoreListeners();
  }

  function update(time, delta) {
    if (questionActive || storeOpen) return;

    let interval = dropInterval;
    if (cursors && cursors.down && cursors.down.isDown) {
      interval = dropInterval / 5;
    }

    dropTimer += delta;
    if (dropTimer >= interval) {
      dropTimer = 0;
      const lines = board.stepDown();
      if (lines > 0) onLinesCleared(lines);
    }

    drawBoard();
  }

  function drawBoard() {
    graphics.clear();
    const colors = {
      1: 0xcc6666,
      2: 0x66cc66,
      3: 0x6666cc,
      4: 0xcccc66,
      5: 0xcc66cc,
      6: 0x66cccc,
      7: 0xdaaa00,
      8: 0x999999
    };

    graphics.lineStyle(1, 0x111122, 0.5);
    for (let x = 0; x <= WIDTH; x++) {
      graphics.strokeLineShape(new Phaser.Geom.Line(x * GRID, 0, x * GRID, HEIGHT * GRID));
    }
    for (let y = 0; y <= HEIGHT; y++) {
      graphics.strokeLineShape(new Phaser.Geom.Line(0, y * GRID, WIDTH * GRID, y * GRID));
    }

    for (let x = 0; x < WIDTH; x++) {
      for (let y = 0; y < HEIGHT; y++) {
        const val = board.value(x, y);
        if (val > 0) {
          graphics.fillStyle(colors[val] || 0xffffff, 1);
          graphics.fillRect(x * GRID + 2, y * GRID + 2, GRID - 4, GRID - 4);
        }
      }
    }

    if (board.currentShape !== SHAPES.NONE) {
      const coords = board.coords(board.currentShape, board.currentDir, board.currentX, board.currentY);
      for (const [x, y] of coords) {
        graphics.fillStyle(colors[board.currentShape] || 0xffffff, 1);
        graphics.fillRect(x * GRID + 2, y * GRID + 2, GRID - 4, GRID - 4);
      }
    }
  }

  // ==========================
  // 6. SCORING + HUD + PLAYER DOC
  // ==========================
  function onLinesCleared(lines) {
    linesCleared += lines;
    score += lines * 100;
    coins += lines;
    recalcScore();
    playSfx('line');
  }

  function recalcScore() {
    hudScore.textContent = score;
    hudLines.textContent = linesCleared;
    hudCoins.textContent = coins;
    hudShield.textContent = shieldActive ? "ON" : "OFF";

    if (!playerDocId) return;
    db.collection('tetrisPlayers').doc(playerDocId).set({
      name: playerName,
      roomId: roomId,
      score: score,
      linesCleared: linesCleared,
      coins: coins,
      shield: shieldActive,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  }

  // ==========================
  // 7. FIRESTORE LISTENERS
  // ==========================
  function setupFirestoreListeners() {
    db.collection('tetrisPlayers')
      .where('roomId', '==', roomId)
      .onSnapshot(snapshot => {
        const players = [];
        snapshot.forEach(doc => {
          players.push({ id: doc.id, ...doc.data() });
        });
        currentPlayers = players;

        if (players.length === 0) {
          leaderboardBody.textContent = "Waiting for players...";
        } else {
          const sorted = [...players].sort((a, b) => (b.score || 0) - (a.score || 0));
          leaderboardBody.innerHTML = sorted.map((p, i) =>
            `${i + 1}. ${p.name}: ${p.score || 0} (${p.coins || 0}c)`
          ).join("<br>");
        }
      });

    if (!playerDocId) return;
    db.collection('tetrisAttacks')
      .where('roomId', '==', roomId)
      .where('toId', '==', playerDocId)
      .onSnapshot(snapshot => {
        snapshot.docChanges().forEach(change => {
          if (change.type === 'added') {
            handleIncomingAttack(change.doc);
          }
        });
      });
  }

  async function handleIncomingAttack(doc) {
    const attack = doc.data();
    if (attack.resolved) return;

    if (shieldActive) {
      shieldActive = false;
      recalcScore();
    } else {
      if (attack.type === 'garbage2') board.addGarbageLines(2);
      if (attack.type === 'garbage4') board.addGarbageLines(4);
      playSfx('hit');
    }
    await doc.ref.update({ resolved: true });
  }

  async function sendAttack(type) {
    const opponents = currentPlayers.filter(p => p.id !== playerDocId);
    if (opponents.length === 0) {
      alert("No opponents in this room yet.");
      return;
    }
    const target = opponents[Math.floor(Math.random() * opponents.length)];

    await db.collection('tetrisAttacks').add({
      roomId: roomId,
      fromId: playerDocId,
      fromName: playerName,
      toId: target.id,
      toName: target.name,
      type: type,
      timestamp: Date.now(),
      resolved: false
    });

    playSfx('attack');
    alert(`Sent ${type} to ${target.name}!`);
  }

  // ==========================
  // 8. STORE
  // ==========================
  btnGarbage2.onclick = () => buyItem('garbage2');
  btnGarbage4.onclick = () => buyItem('garbage4');
  btnShield.onclick = () => buyItem('shield');
  btnClear.onclick = () => buyItem('clear');
  btnStoreClose.onclick = () => closeStore();

  function openStore() {
    storeOpen = true;
    storeOverlay.classList.remove('hidden');
  }
  function closeStore() {
    storeOpen = false;
    storeOverlay.classList.add('hidden');
  }

  function buyItem(type) {
    const costMap = { garbage2: 3, garbage4: 5, shield: 4, clear: 5 };
    const cost = costMap[type];
    if (coins < cost) {
      alert("Not enough coins.");
      return;
    }
    coins -= cost;

    if (type === 'shield') {
      shieldActive = true;
      recalcScore();
    } else if (type === 'clear') {
      board.clearBottomLines(2);
      recalcScore();
    } else {
      sendAttack(type);
      recalcScore();
    }
  }

  // ==========================
  // 9. QUIZ OVERLAY
  // ==========================
  function askQuestion() {
    if (questionActive) return;
    if (questionIndex >= QUESTIONS.length) return;

    questionActive = true;
    const q = QUESTIONS[questionIndex++];
    questionText.textContent = q.text;
    answersDiv.innerHTML = "";

    q.options.forEach((opt, idx) => {
      const btn = document.createElement('button');
      btn.className = 'answer-btn';
      btn.textContent = opt;
      btn.onclick = () => {
        const correct = idx === q.correctIndex;
        if (correct) {
          board.clearTopFilledRow();
          coins += 3;
          playSfx('line');
        } else {
          board.addGarbageLines(2);
          playSfx('hit');
        }
        recalcScore();
        questionOverlay.classList.add('hidden');
        questionActive = false;
      };
      answersDiv.appendChild(btn);
    });

    questionOverlay.classList.remove('hidden');
  }
</script>
</body>
</html>
