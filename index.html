<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Battle Tetris</title>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>

  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

  <style>
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #2a2a5a 0%, #111133 35%, #03030a 70%, #000 100%);
      color: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
    }
    #top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 16px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      font-size: 14px;
      border-bottom: 2px solid #444;
      box-shadow: 0 2px 8px #000;
    }
    #hud {
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    #hud strong {
      color: #ffcc00;
    }
    #bgm-toggle {
      cursor: pointer;
      color: #90caf9;
    }
    #bgm-toggle:hover {
      text-decoration: underline;
    }
    #content {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
    }
    #game-container {
      border: 3px solid #888;
      box-shadow: 0 0 20px #000, 0 0 40px rgba(255, 152, 0, 0.2);
      background: #000;
    }
    #leaderboard {
      width: 240px;
      background: rgba(5, 5, 15, 0.95);
      color: #fff;
      border: 2px solid #555;
      padding: 10px;
      font-size: 14px;
      box-shadow: 0 0 20px #000;
      border-radius: 8px;
    }
    #leaderboard h3 {
      margin: 0 0 6px 0;
      font-size: 18px;
      text-align: center;
      letter-spacing: 1px;
      text-transform: uppercase;
      color: #ffcc00;
      text-shadow: 0 0 6px #ff9800;
    }

    /* Profile card with face + neon title */
    #profile-card {
      width: 220px;
      background: rgba(5, 5, 20, 0.95);
      color: #fff;
      border: 2px solid #555;
      padding: 10px;
      font-size: 14px;
      box-shadow: 0 0 20px #000;
      border-radius: 8px;
      text-align: center;
    }
    .profile-title {
      margin-bottom: 8px;
      font-size: 20px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: #ffcc00;
      text-shadow:
        0 0 6px #ff9800,
        0 0 12px #ff9800,
        0 0 16px #ff5722;
      animation: titlePulse 1.4s infinite alternate;
    }
    #profile-face {
      width: 100%;
      height: auto;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(255,255,255,0.2);
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(40,40,80,0.95), rgba(0,0,0,0.95));
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      z-index: 10;
    }
    .hidden {
      display: none !important;
    }
    .overlay-box {
      background: linear-gradient(145deg, #060614, #111122);
      padding: 20px 24px;
      border-radius: 12px;
      max-width: 520px;
      text-align: center;
      box-shadow: 0 0 25px #000, 0 0 40px rgba(0, 255, 255, 0.25);
      border: 2px solid #444;
    }
    .overlay-box h1 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 32px;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: #ffcc00;
      text-shadow:
        0 0 6px #ff9800,
        0 0 12px #ff9800,
        0 0 16px #ff5722;
    }
    /* Pulsating neon title (reused for title + profile card) */
    #title-text {
      animation: titlePulse 1.4s infinite alternate;
    }
    @keyframes titlePulse {
      from {
        transform: scale(1);
        text-shadow:
          0 0 6px #ff9800,
          0 0 12px #ff9800,
          0 0 16px #ff5722;
      }
      to {
        transform: scale(1.08);
        text-shadow:
          0 0 10px #ffeb3b,
          0 0 20px #ffc107,
          0 0 30px #ff5722;
      }
    }

    .overlay-box h2 {
      margin-top: 8px;
      font-size: 20px;
      color: #90caf9;
    }
    .overlay-box p {
      font-size: 14px;
    }
    .overlay-box input {
      width: 80%;
      padding: 6px;
      margin: 4px 0 10px 0;
      border-radius: 4px;
      border: 1px solid #555;
      font-size: 14px;
      background: #050514;
      color: #fff;
    }
    .overlay-box button {
      margin: 6px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .answer-btn {
      background: #4caf50;
      color: #fff;
    }
    .store-btn {
      background: #2196f3;
      color: #fff;
    }
    .close-btn {
      background: #777;
      color: #fff;
    }
    .primary-btn {
      background: linear-gradient(90deg, #ff9800, #ffc107);
      color: #000;
      font-weight: bold;
      box-shadow: 0 0 10px #ff9800;
    }
    .copyright-text {
      margin-top: 12px;
      font-size: 11px;
      opacity: 0.8;
    }
    #footer {
      text-align: center;
      padding: 4px 8px;
      font-size: 11px;
      background: rgba(0,0,0,0.9);
      color: #ccc;
      border-top: 1px solid #333;
    }

    /* Attack banner */
    #attack-banner {
      position: fixed;
      top: 52px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 12px;
      background: rgba(200, 0, 0, 0.92);
      border-radius: 6px;
      border: 1px solid #ffaaaa;
      font-size: 14px;
      box-shadow: 0 0 12px #f44336;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease-out;
      z-index: 9;
    }
    #attack-banner.visible {
      opacity: 1;
    }

    /* Game over banner */
    #game-over-banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 12px 20px;
      background: rgba(0,0,0,0.9);
      border-radius: 8px;
      border: 2px solid #ff5252;
      font-size: 24px;
      text-shadow: 0 0 10px #ff5252;
      box-shadow: 0 0 18px #000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease-out;
      z-index: 12;
    }
    #game-over-banner.visible {
      opacity: 1;
    }
  </style>
</head>
<body>

<div id="top-bar">
  <div id="hud">
    <span id="hud-name"></span> |
    Score: <span id="hud-score">0</span> |
    Lines: <span id="hud-lines">0</span> |
    Coins: <span id="hud-coins">0</span> |
    Shield: <span id="hud-shield">OFF</span>
    &nbsp;&nbsp;&nbsp;
    <strong>[E] Store</strong>
    &nbsp;&nbsp;&nbsp;
    <span id="bgm-toggle">[M] Music: ON</span>
  </div>
  <div>
    Room: <span id="hud-room"></span>
  </div>
</div>

<div id="content">
  <div id="game-container"></div>

  <div id="leaderboard">
    <h3>Leaderboard</h3>
    <div id="leaderboard-body">Waiting for players...</div>
  </div>

  <div id="profile-card">
    <div class="profile-title">Battle Tetris</div>
    <img id="profile-face" src="face.png" alt="Jason Slaughter">
  </div>
</div>

<div id="footer">
  Copyright 2025 Jason Slaughter PixelED Path, LLC
</div>

<div id="start-overlay" class="overlay">
  <div class="overlay-box">
    <h1 id="title-text">Battle Tetris</h1>
    <p>Answer questions, clear lines, earn coins, and attack your classmates.</p>
    <h2>Join Game</h2>
    <input id="start-name" placeholder="Your name" />
    <br>
    <input id="start-room" placeholder="Room code (e.g., Hour1)" value="Room1" />
    <br>
    <button id="start-button" class="primary-btn">Start</button>
    <p style="margin-top:10px;font-size:12px;">
      Everyone with the same room code shares a leaderboard and can attack each other.
    </p>
    <p class="copyright-text">
      Copyright 2025 Jason Slaughter PixelED Path, LLC
    </p>
  </div>
</div>

<div id="question-overlay" class="overlay hidden">
  <div class="overlay-box">
    <h2>Answer the question!</h2>
    <div id="question-text" style="margin-bottom: 10px;"></div>
    <div id="answers"></div>
  </div>
</div>

<div id="store-overlay" class="overlay hidden">
  <div class="overlay-box">
    <h2>Store</h2>
    <p>Use coins to attack or defend.</p>
    <p><strong>Attacks (hit first place opponent in your room):</strong></p>
    <button class="store-btn" id="buy-garbage2">Garbage +2 (3 coins)</button>
    <button class="store-btn" id="buy-garbage4">Garbage +4 (5 coins)</button>
    <p><strong>Defense / Utility:</strong></p>
    <button class="store-btn" id="buy-shield">Shield (next attack blocked) (4 coins)</button>
    <button class="store-btn" id="buy-clear">Clear 2 bottom lines (5 coins)</button>
    <br><br>
    <button class="close-btn" id="store-close">Close Store (E)</button>
  </div>
</div>

<div id="attack-banner"></div>
<div id="game-over-banner">GAME OVER â€“ Board Reset</div>

<script>
  // ==========================
  // 1. FIREBASE CONFIG
  // ==========================
  const firebaseConfig = {
    apiKey: "AIzaSyCclM56_skM11x7_qXW08eB2gx-n7T9tJY",
    authDomain: "battle-tetris-2c247.firebaseapp.com",
    projectId: "battle-tetris-2c247",
    storageBucket: "battle-tetris-2c247.firebasestorage.app",
    messagingSenderId: "275712305914",
    appId: "1:275712305914:web:b5115418725f5703163743",
    measurementId: "G-ZQBZYEY1EK"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // ==========================
  // 2. QUESTION BANK (20 from Phoenicians text)
  // ==========================
  const BASE_QUESTIONS = [
    {
      text: "Where did the Phoenician civilization begin?",
      correct: "On a narrow Mediterranean coastal strip in present-day Lebanon",
      wrong: [
        "Deep in the Sahara Desert",
        "In the Nile River valley of Egypt",
        "On the plains between the Tigris and Euphrates Rivers"
      ]
    },
    {
      text: "What type of political units made up Phoenicia?",
      correct: "Independent city-states",
      wrong: [
        "A single united empire",
        "Nomadic tribes",
        "Democratic kingdoms"
      ]
    },
    {
      text: "From which earlier people did Phoenician society develop?",
      correct: "The Canaanites",
      wrong: [
        "The Assyrians",
        "The Persians",
        "The Hittites"
      ]
    },
    {
      text: "Which large civilization strongly influenced Canaan and sometimes controlled it?",
      correct: "Egypt",
      wrong: [
        "India",
        "China",
        "Rome"
      ]
    },
    {
      text: "Why did geography push Phoenicians toward the sea?",
      correct: "Mountainous land left little flat area for farming",
      wrong: [
        "Endless flat plains made farming too boring",
        "They lived on islands with no land at all",
        "Their rivers were too dangerous to cross"
      ]
    },
    {
      text: "What rare product made from sea snails made Phoenicia famous?",
      correct: "Purple dye used to color cloth",
      wrong: [
        "Black ink for writing",
        "Perfume oil for temples",
        "Blue paint for pottery"
      ]
    },
    {
      text: "Which statement best describes Phoenician sailors?",
      correct: "They were fearless navigators who dominated Mediterranean sea trade",
      wrong: [
        "They only sailed short distances along rivers",
        "They avoided ocean travel and used only roads",
        "They depended on other peoples to move their goods by sea"
      ]
    },
    {
      text: "What is an import?",
      correct: "A good made in another country and brought in to be sold",
      wrong: [
        "A good produced in a country and sold to others",
        "A tax charged on local merchants",
        "A law that limits trade with neighbors"
      ]
    },
    {
      text: "What is an export?",
      correct: "A good produced in a country and sold outside its borders",
      wrong: [
        "A good bought from another country",
        "A type of ship used for sea travel",
        "A list of trading rules"
      ]
    },
    {
      text: "Why did the Phoenicians trade so much with other cultures?",
      correct: "They lacked many natural resources and needed raw materials",
      wrong: [
        "They wanted to avoid contact with all outsiders",
        "They had no skills in manufacturing",
        "Their religion forbade them from farming"
      ]
    },
    {
      text: "Which raw materials did Phoenicians often bring back as imports?",
      correct: "Gold, silver, tin, copper, iron, ivory, and precious stones",
      wrong: [
        "Silk, tea, and gunpowder from Asia",
        "Corn, potatoes, and tobacco from the Americas",
        "Coal, steel, and plastic from Europe"
      ]
    },
    {
      text: "What is navigation?",
      correct: "The art of steering a ship from place to place",
      wrong: [
        "The process of building stone temples",
        "A law about how merchants must trade",
        "The writing system used by priests"
      ]
    },
    {
      text: "Which evidence shows that Phoenicians were highly skilled sailors?",
      correct: "They explored far across the Mediterranean and even into the Atlantic Ocean",
      wrong: [
        "They never left sight of their home ports",
        "They only sailed short trips to one nearby island",
        "They refused to trade with any foreign lands"
      ]
    },
    {
      text: "What is a colony?",
      correct: "An area ruled by a distant country",
      wrong: [
        "A small independent kingdom",
        "A ship used for long voyages",
        "A temple in a city-state"
      ]
    },
    {
      text: "Why did many Phoenicians move to their colonies starting in the 800s BCE?",
      correct: "They were fleeing attacks from the Assyrians and others",
      wrong: [
        "They were ordered to leave by their kings",
        "They were searching for fertile river valleys in Mesopotamia",
        "They were forced into slavery by the Egyptians"
      ]
    },
    {
      text: "Which Phoenician colony grew into a powerful city-state in North Africa?",
      correct: "Carthage",
      wrong: [
        "Babylon",
        "Memphis",
        "Sparta"
      ]
    },
    {
      text: "What is cultural diffusion?",
      correct: "The spreading of cultural traits from one region to another",
      wrong: [
        "The complete isolation of one culture from others",
        "A written law code controlling trade",
        "The process of building stone monuments"
      ]
    },
    {
      text: "How did the Phoenicians help spread culture around the Mediterranean?",
      correct: "Through trade, they linked many peoples and passed on ideas and practices",
      wrong: [
        "By refusing to trade with any foreign groups",
        "By destroying all cities they visited",
        "By forcing everyone to speak only one language"
      ]
    },
    {
      text: "How was the Phoenician alphabet different from older cuneiform writing?",
      correct: "It used a small set of symbols, each representing a single sound",
      wrong: [
        "It used thousands of picture symbols for entire words",
        "It could only be carved into clay tablets",
        "It was a secret code known only to kings"
      ]
    },
    {
      text: "Which later cultures adopted and changed the Phoenician alphabet?",
      correct: "Greeks and Romans",
      wrong: [
        "Chinese and Japanese",
        "Aztecs and Mayans",
        "Incas and Egyptians"
      ]
    }
  ];

  let questionPool = [];
  function resetQuestionPool() {
    questionPool = BASE_QUESTIONS.map(q => ({ ...q, wrong: [...q.wrong] }));
  }
  resetQuestionPool();

  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // ==========================
  // 3. GLOBAL VARS
  // ==========================
  const WIDTH = 10;
  const HEIGHT = 22;
  const GRID = 32;

  let board;
  let game;
  let graphics;

  let score = 0;
  let linesCleared = 0;
  let coins = 0;
  let shieldActive = false;

  let questionActive = false;
  let storeOpen = false;

  let dropTimer = 0;
  let dropInterval = 500;
  let cursors;
  let keySpace;
  let keyE;

  // horizontal move smoothing
  let moveDir = 0;          // -1 left, 1 right, 0 none
  let moveHoldTime = 0;
  const MOVE_INITIAL_DELAY = 170; // ms before auto-repeat
  const MOVE_REPEAT_DELAY  = 60;  // ms between repeats

  let playerName = "Player";
  let roomId = "Room1";
  let playerDocId = null;

  let currentPlayers = [];

  // HTML5 Audio for SFX/BGM
  const sfx = {
    move:   new Audio("sounds/move.mp3"),
    rotate: new Audio("sounds/rotate.mp3"),
    drop:   new Audio("sounds/drop.mp3"),
    line:   new Audio("sounds/line.mp3"),
    attack: new Audio("sounds/attack.mp3"),
    hit:    new Audio("sounds/hit.mp3")
  };
  sfx.move.volume = 0.25;
  sfx.rotate.volume = 0.25;
  sfx.drop.volume = 0.3;
  sfx.line.volume = 0.35;
  sfx.attack.volume = 0.4;
  sfx.hit.volume = 0.4;

  const bgm = new Audio("sounds/bgm.mp3");
  bgm.loop = true;
  bgm.volume = 0.25;
  let musicEnabled = true;

  function playSfx(name) {
    const sound = sfx[name];
    if (!sound) return;
    try {
      sound.currentTime = 0;
      sound.play();
    } catch (e) {}
  }

  const hudName = document.getElementById('hud-name');
  const hudScore = document.getElementById('hud-score');
  const hudLines = document.getElementById('hud-lines');
  const hudCoins = document.getElementById('hud-coins');
  const hudShield = document.getElementById('hud-shield');
  const hudRoom = document.getElementById('hud-room');
  const leaderboardBody = document.getElementById('leaderboard-body');

  const startOverlay = document.getElementById('start-overlay');
  const startNameInput = document.getElementById('start-name');
  const startRoomInput = document.getElementById('start-room');
  const startButton = document.getElementById('start-button');

  const storeOverlay = document.getElementById('store-overlay');
  const btnGarbage2 = document.getElementById('buy-garbage2');
  const btnGarbage4 = document.getElementById('buy-garbage4');
  const btnShield = document.getElementById('buy-shield');
  const btnClear = document.getElementById('buy-clear');
  const btnStoreClose = document.getElementById('store-close');

  const questionOverlay = document.getElementById('question-overlay');
  const questionText = document.getElementById('question-text');
  const answersDiv = document.getElementById('answers');

  const bgmToggle = document.getElementById('bgm-toggle');
  const attackBanner = document.getElementById('attack-banner');
  const gameOverBanner = document.getElementById('game-over-banner');

  function updateBgmLabel() {
    bgmToggle.textContent = musicEnabled ? "[M] Music: ON" : "[M] Music: OFF";
  }
  updateBgmLabel();

  function toggleMusic() {
    musicEnabled = !musicEnabled;
    updateBgmLabel();
    if (!musicEnabled) {
      bgm.pause();
    } else {
      try { bgm.play(); } catch (e) {}
    }
  }
  bgmToggle.onclick = toggleMusic;

  function showAttackBanner(text) {
    attackBanner.textContent = text;
    attackBanner.classList.add('visible');
    clearTimeout(showAttackBanner._timeoutId);
    showAttackBanner._timeoutId = setTimeout(() => {
      attackBanner.classList.remove('visible');
    }, 3000);
  }

  function showGameOverBanner() {
    gameOverBanner.classList.add('visible');
    clearTimeout(showGameOverBanner._timeoutId);
    showGameOverBanner._timeoutId = setTimeout(() => {
      gameOverBanner.classList.remove('visible');
    }, 2000);
  }

  // Start screen handler
  startButton.onclick = () => {
    playerName = (startNameInput.value || "Anonymous").trim();
    roomId = (startRoomInput.value || "Room1").trim();
    playerDocId = playerName + "_" + Math.floor(Math.random() * 1000000);

    hudName.textContent = playerName;
    hudRoom.textContent = roomId;

    startOverlay.classList.add('hidden');

    if (musicEnabled) {
      try { bgm.play(); } catch (e) {}
    }

    startGame();
  };

  // ==========================
  // 4. TETRIS LOGIC
  // ==========================
  const SHAPES = {
    NONE: 0,
    I: 1,
    L: 2,
    J: 3,
    T: 4,
    O: 5,
    S: 6,
    Z: 7
  };

  const SHAPE_COORDS = {
    [SHAPES.NONE]: [[0,0],[0,0],[0,0],[0,0]],
    [SHAPES.I]:    [[0,-1],[0,0],[0,1],[0,2]],
    [SHAPES.L]:    [[0,-1],[0,0],[0,1],[1,1]],
    [SHAPES.J]:    [[0,-1],[0,0],[0,1],[-1,1]],
    [SHAPES.T]:    [[0,-1],[0,0],[0,1],[1,0]],
    [SHAPES.O]:    [[0,0],[0,-1],[1,0],[1,-1]],
    [SHAPES.S]:    [[0,0],[0,-1],[-1,0],[1,-1]],
    [SHAPES.Z]:    [[0,0],[0,-1],[1,0],[-1,-1]]
  };

  function rotatedOffsets(shape, dir) {
    const coords = SHAPE_COORDS[shape];
    if (dir === 0 || shape === SHAPES.O) return coords;

    if (dir === 1) {
      return coords.map(([x,y]) => [-y, x]);
    }
    if (dir === 2) {
      if ([SHAPES.I, SHAPES.Z, SHAPES.S].includes(shape)) return coords;
      return coords.map(([x,y]) => [-x, -y]);
    }
    if (dir === 3) {
      if ([SHAPES.I, SHAPES.Z, SHAPES.S].includes(shape)) {
        return coords.map(([x,y]) => [-y, x]);
      }
      return coords.map(([x,y]) => [y, -x]);
    }
  }

  // gameOver reset when stack reaches top
  function gameOver() {
    if (!board) return;
    board.backBoard.fill(0);
    score = 0;
    linesCleared = 0;
    coins = 0;
    shieldActive = false;
    recalcScore();
    showGameOverBanner();
  }

  class Board {
    constructor() {
      this.width = WIDTH;
      this.height = HEIGHT;
      this.backBoard = new Array(WIDTH * HEIGHT).fill(0);
      this.currentShape = SHAPES.NONE;
      this.currentX = -1;
      this.currentY = -1;
      this.currentDir = 0;
      this.nextShape = this.randomShape();
    }
    randomShape() {
      return 1 + Math.floor(Math.random() * 7);
    }
    value(x,y) {
      return this.backBoard[x + y * this.width];
    }
    coords(shape, dir, x, y) {
      return rotatedOffsets(shape, dir).map(([dx,dy]) => [x + dx, y + dy]);
    }
    tryMove(shape, dir, x, y) {
      for (const [xx, yy] of this.coords(shape, dir, x, y)) {
        if (xx < 0 || xx >= this.width || yy < 0 || yy >= this.height) return false;
        if (this.backBoard[xx + yy * this.width] > 0) return false;
      }
      return true;
    }
    spawn() {
      const shape = this.nextShape;
      this.currentShape = shape;
      this.currentDir = 0;
      this.currentX = 5;
      this.currentY = 1;
      this.nextShape = this.randomShape();

      // if we can't spawn, that means stack reached top -> game over & board cleared
      if (!this.tryMove(this.currentShape, this.currentDir, this.currentX, this.currentY)) {
        gameOver();
      }
    }
    stepDown() {
      if (this.tryMove(this.currentShape, this.currentDir, this.currentX, this.currentY + 1)) {
        this.currentY++;
        return 0;
      }
      this.merge();
      const lines = this.removeFullLines();
      this.spawn();
      return lines;
    }
    dropDown() {
      while (this.tryMove(this.currentShape, this.currentDir, this.currentX, this.currentY + 1)) {
        this.currentY++;
      }
      this.merge();
      const lines = this.removeFullLines();
      this.spawn();
      return lines;
    }
    merge() {
      for (const [x,y] of this.coords(this.currentShape, this.currentDir, this.currentX, this.currentY)) {
        this.backBoard[x + y * this.width] = this.currentShape;
      }
      this.currentShape = SHAPES.NONE;
    }
    removeFullLines() {
      let lines = 0;
      const newBoard = new Array(this.width * this.height).fill(0);
      let newY = this.height - 1;
      for (let y = this.height - 1; y >= 0; y--) {
        let count = 0;
        for (let x = 0; x < this.width; x++) {
          if (this.backBoard[x + y * this.width] > 0) count++;
        }
        if (count < this.width) {
          for (let x = 0; x < this.width; x++) {
            newBoard[x + newY * this.width] = this.backBoard[x + y * this.width];
          }
          newY--;
        } else {
          lines++;
        }
      }
      this.backBoard = newBoard;
      return lines;
    }
    clearTopFilledRow() {
      for (let y = 0; y < this.height; y++) {
        let any = false;
        for (let x = 0; x < this.width; x++) {
          if (this.backBoard[x + y * this.width] > 0) {
            any = true;
            break;
          }
        }
        if (any) {
          for (let x = 0; x < this.width; x++) {
            this.backBoard[x + y * this.width] = 0;
          }
          return;
        }
      }
    }
    addGarbageLines(count) {
      for (let i = 0; i < count; i++) {
        for (let y = 0; y < this.height - 1; y++) {
          for (let x = 0; x < this.width; x++) {
            this.backBoard[x + y * this.width] = this.backBoard[x + (y + 1) * this.width];
          }
        }
        const hole = Math.floor(Math.random() * this.width);
        for (let x = 0; x < this.width; x++) {
          this.backBoard[x + (this.height - 1) * this.width] = (x === hole) ? 0 : 8;
        }
      }
    }
    clearBottomLines(count) {
      for (let c = 0; c < count; c++) {
        for (let x = 0; x < this.width; x++) {
          this.backBoard[x + (this.height - 1) * this.width] = 0;
        }
      }
    }
  }

  // simple wall-kick rotate
  function attemptRotate(delta) {
    if (!board || board.currentShape === SHAPES.NONE) return;
    const newDir = (board.currentDir + delta + 4) % 4;
    const x = board.currentX;
    const y = board.currentY;

    if (board.tryMove(board.currentShape, newDir, x, y)) {
      board.currentDir = newDir;
      playSfx('rotate');
      return;
    }
    if (board.tryMove(board.currentShape, newDir, x - 1, y)) {
      board.currentX = x - 1;
      board.currentDir = newDir;
      playSfx('rotate');
      return;
    }
    if (board.tryMove(board.currentShape, newDir, x + 1, y)) {
      board.currentX = x + 1;
      board.currentDir = newDir;
      playSfx('rotate');
      return;
    }
  }

  // ==========================
  // 5. START GAME (PHASER)
  // ==========================
  function startGame() {
    const config = {
      type: Phaser.AUTO,
      width: WIDTH * GRID,
      height: HEIGHT * GRID,
      parent: 'game-container',
      backgroundColor: '#050814',
      scene: { preload, create, update }
    };
    game = new Phaser.Game(config);

    window.addEventListener('beforeunload', () => {
      if (playerDocId) {
        db.collection('tetrisPlayers').doc(playerDocId).delete().catch(() => {});
      }
    });
  }

  function preload() {
    // no Phaser audio assets; using HTML Audio
  }

  function create() {
    board = new Board();
    board.spawn();
    graphics = this.add.graphics();

    cursors = this.input.keyboard.createCursorKeys();
    keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    keyE = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

    keySpace.on('down', () => {
      if (questionActive || storeOpen) return;
      const lines = board.dropDown();
      playSfx('drop');
      if (lines > 0) onLinesCleared(lines);
    });

    this.input.keyboard.on('keydown', (event) => {
      if (questionActive || storeOpen) return;
      switch (event.code) {
        case 'ArrowLeft':
          if (board.tryMove(board.currentShape, board.currentDir, board.currentX - 1, board.currentY)) {
            board.currentX--;
            playSfx('move');
          }
          moveDir = -1;
          moveHoldTime = 0;
          break;
        case 'ArrowRight':
          if (board.tryMove(board.currentShape, board.currentDir, board.currentX + 1, board.currentY)) {
            board.currentX++;
            playSfx('move');
          }
          moveDir = 1;
          moveHoldTime = 0;
          break;
        case 'ArrowUp':
          attemptRotate(1);
          break;
        case 'KeyM':
          toggleMusic();
          break;
      }
    });

    this.input.keyboard.on('keyup', (event) => {
      if (event.code === 'ArrowLeft' && moveDir === -1) {
        moveDir = 0;
        moveHoldTime = 0;
      }
      if (event.code === 'ArrowRight' && moveDir === 1) {
        moveDir = 0;
        moveHoldTime = 0;
      }
    });

    keyE.on('down', () => {
      if (questionActive) return;
      if (storeOpen) closeStore();
      else openStore();
    });

    // question every 60s
    this.time.addEvent({
      delay: 60000,
      loop: true,
      callback: () => {
        if (!storeOpen) askQuestion();
      }
    });

    recalcScore();
    setupFirestoreListeners();
  }

  function update(time, delta) {
    if (questionActive || storeOpen) return;

    let interval = dropInterval;
    if (cursors && cursors.down && cursors.down.isDown) {
      interval = dropInterval / 5;
    }

    dropTimer += delta;
    if (dropTimer >= interval) {
      dropTimer = 0;
      const lines = board.stepDown();
      if (lines > 0) onLinesCleared(lines);
    }

    // smooth horizontal auto-shift when holding left/right
    if (moveDir !== 0 && board && board.currentShape !== SHAPES.NONE) {
      moveHoldTime += delta;
      if (moveHoldTime >= MOVE_INITIAL_DELAY) {
        const newX = board.currentX + moveDir;
        if (board.tryMove(board.currentShape, board.currentDir, newX, board.currentY)) {
          board.currentX = newX;
          playSfx('move');
        }
        moveHoldTime -= MOVE_REPEAT_DELAY;
        if (moveHoldTime < MOVE_INITIAL_DELAY - MOVE_REPEAT_DELAY) {
          moveHoldTime = MOVE_INITIAL_DELAY - MOVE_REPEAT_DELAY;
        }
      }
    }

    drawBoard();
  }

  function drawBoard() {
    graphics.clear();
    const colors = {
      1: 0xcc6666,
      2: 0x66cc66,
      3: 0x6666cc,
      4: 0xcccc66,
      5: 0xcc66cc,
      6: 0x66cccc,
      7: 0xdaaa00,
      8: 0x999999
    };

    graphics.lineStyle(1, 0x111122, 0.5);
    for (let x = 0; x <= WIDTH; x++) {
      graphics.strokeLineShape(new Phaser.Geom.Line(x * GRID, 0, x * GRID, HEIGHT * GRID));
    }
    for (let y = 0; y <= HEIGHT; y++) {
      graphics.strokeLineShape(new Phaser.Geom.Line(0, y * GRID, WIDTH * GRID, y * GRID));
    }

    for (let x = 0; x < WIDTH; x++) {
      for (let y = 0; y < HEIGHT; y++) {
        const val = board.value(x, y);
        if (val > 0) {
          graphics.fillStyle(colors[val] || 0xffffff, 1);
          graphics.fillRect(x * GRID + 2, y * GRID + 2, GRID - 4, GRID - 4);
        }
      }
    }

    if (board.currentShape !== SHAPES.NONE) {
      const coords = board.coords(board.currentShape, board.currentDir, board.currentX, board.currentY);
      for (const [x, y] of coords) {
        graphics.fillStyle(colors[board.currentShape] || 0xffffff, 1);
        graphics.fillRect(x * GRID + 2, y * GRID + 2, GRID - 4, GRID - 4);
      }
    }
  }

  // ==========================
  // 6. SCORING + HUD + PLAYER DOC
  // ==========================
  function onLinesCleared(lines) {
    linesCleared += lines;
    score += lines * 100;
    coins += lines;
    recalcScore();
    playSfx('line');
  }

  function recalcScore() {
    hudScore.textContent = score;
    hudLines.textContent = linesCleared;
    hudCoins.textContent = coins;
    hudShield.textContent = shieldActive ? "ON" : "OFF";

    if (!playerDocId) return;
    db.collection('tetrisPlayers').doc(playerDocId).set({
      name: playerName,
      roomId: roomId,
      score: score,
      linesCleared: linesCleared,
      coins: coins,
      shield: shieldActive,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  }

  // ==========================
  // 7. FIRESTORE LISTENERS
  // ==========================
  function setupFirestoreListeners() {
    db.collection('tetrisPlayers')
      .where('roomId', '==', roomId)
      .onSnapshot(snapshot => {
        const players = [];
        snapshot.forEach(doc => {
          players.push({ id: doc.id, ...doc.data() });
        });
        currentPlayers = players;

        if (players.length === 0) {
          leaderboardBody.textContent = "Waiting for players...";
        } else {
          const sorted = [...players].sort((a, b) => (b.score || 0) - (a.score || 0));
          leaderboardBody.innerHTML = sorted.map((p, i) =>
            `${i + 1}. ${p.name}: ${p.score || 0} (${p.coins || 0}c)`
          ).join("<br>");
        }
      });

    if (!playerDocId) return;
    db.collection('tetrisAttacks')
      .where('roomId', '==', roomId)
      .where('toId', '==', playerDocId)
      .onSnapshot(snapshot => {
        snapshot.docChanges().forEach(change => {
          if (change.type === 'added') {
            handleIncomingAttack(change.doc);
          }
        });
      });
  }

  async function handleIncomingAttack(doc) {
    const attack = doc.data();
    if (attack.resolved) return;

    let msg;
    if (shieldActive) {
      msg = `Blocked attack from ${attack.fromName}!`;
      shieldActive = false;
      playSfx('hit');
      recalcScore();
    } else {
      if (attack.type === 'garbage2') {
        board.addGarbageLines(2);
        msg = `${attack.fromName} hit you: +2 garbage lines!`;
      } else if (attack.type === 'garbage4') {
        board.addGarbageLines(4);
        msg = `${attack.fromName} hit you HARD: +4 garbage lines!`;
      } else {
        msg = `Attack from ${attack.fromName}!`;
      }
      playSfx('hit');
    }
    showAttackBanner(msg);
    await doc.ref.update({ resolved: true });
  }

  async function sendAttack(type) {
    const myId = playerDocId;

    // 1. Sort players to find the first place opponent
    const opponents = currentPlayers.filter(p => p.id !== myId);
    if (opponents.length === 0) {
      alert("No opponents in this room yet.");
      return;
    }
    
    // Sort players by score (descending)
    const sortedOpponents = opponents.sort((a, b) => (b.score || 0) - (a.score || 0));
    
    // Target is the first player in the sorted list (the one with the highest score)
    const target = sortedOpponents[0];

    // Check if the target is defined (should always be if opponents.length > 0)
    if (!target) {
        alert("Could not determine a target for the attack.");
        return;
    }

    await db.collection('tetrisAttacks').add({
      roomId: roomId,
      fromId: myId,
      fromName: playerName,
      toId: target.id,
      toName: target.name,
      type: type,
      timestamp: Date.now(),
      resolved: false
    });

    playSfx('attack');
    alert(`Sent ${type} to ${target.name} (1st Place)!`);
  }

  // ==========================
  // 8. STORE
  // ==========================
  btnGarbage2.onclick = () => buyItem('garbage2');
  btnGarbage4.onclick = () => buyItem('garbage4');
  btnShield.onclick = () => buyItem('shield');
  btnClear.onclick = () => buyItem('clear');
  btnStoreClose.onclick = () => closeStore();

  function openStore() {
    storeOpen = true;
    storeOverlay.classList.remove('hidden');
  }
  function closeStore() {
    storeOpen = false;
    storeOverlay.classList.add('hidden');
  }

  function buyItem(type) {
    const costMap = { garbage2: 3, garbage4: 5, shield: 4, clear: 5 };
    const cost = costMap[type];
    if (coins < cost) {
      alert("Not enough coins.");
      return;
    }
    coins -= cost;

    if (type === 'shield') {
      shieldActive = true;
      recalcScore();
    } else if (type === 'clear') {
      board.clearBottomLines(2);
      recalcScore();
    } else {
      sendAttack(type);
      recalcScore();
    }
  }

  // ==========================
  // 9. QUIZ OVERLAY (random question + shuffled answers)
  // ==========================
  function askQuestion() {
    if (questionActive) return;
    if (questionPool.length === 0) resetQuestionPool();

    questionActive = true;
    const idx = Math.floor(Math.random() * questionPool.length);
    const base = questionPool.splice(idx, 1)[0];

    questionText.textContent = base.text;
    answersDiv.innerHTML = "";

    const options = [base.correct, ...base.wrong];
    shuffleArray(options);

    options.forEach(opt => {
      const btn = document.createElement('button');
      btn.className = 'answer-btn';
      btn.textContent = opt;
      btn.onclick = () => {
        const correct = (opt === base.correct);
        if (correct) {
          board.clearTopFilledRow();
          coins += 3;
          playSfx('line');
        } else {
          board.addGarbageLines(2);
          playSfx('hit');
        }
        recalcScore();
        questionOverlay.classList.add('hidden');
        questionActive = false;
      };
      answersDiv.appendChild(btn);
    });

    questionOverlay.classList.remove('hidden');
  }
</script>
</body>
</html>